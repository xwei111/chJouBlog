---
title: typescript之旅
date: 2021-03-04
tags: 
  - typescript
author: 追旅
location: 杭州滨江 
---

## 前言

用ts有段时间了，对于语法规范、错误定位、团队协作都是很有帮助，同时缺点也很明显，需要去学习、开发时间会随之增加，但利大于弊，大趋势就是诸多框架都开始使用ts编写，业务代码也开始大量使用ts，甚至一些旧的业务会使用ts重构，是不是看到这里感觉自己都和时代脱钩了呢，但是没招啊，以前是落后挨打，现在是落后挨饿，所以学起来吧已不是少年的你我！！！

## 基础类型定义

```ts
// 布尔值
const bol: boolean = true;
// 数字
const num: number = 1;
// 字符串
const str: string = 'test';
// 数组 两种写法任选其一
const arr1: Array<number> = [1, 2];
const arr2: number[] = [1, 2];
// 元组 和数组不同各个元素类型不必相同
let arr3: [number, string, boolean] = [1, '2', true];
// 对象
const obj: {
  name: string;
  age: number;
  schools: Array<string>;
  isHangZhou?: boolean;
} = {
  name: 'xw',
  age: 18,
  schools: ["小学", "中学", "大学"]
}
// 任意类型
const test: any = 1;
const test1: any = '2';
// 枚举
enum Provinces { HeNan, ShangHai, BeiJing };
let h = Provinces.HeNan
const provinceName: string = Provinces[0];
const provinceId: Provinces = Provinces.HeNan;
```

## 接口

接口即```interface```，主要是为对象的成员、成员类型的定义

```ts
// 定义成员时，可定义只读和可选
interface Person {
  readonly name: string; // 只读 
  sex: number;
  isGirl?: boolean; // 可选
}

const person: Person = {
  name: 'xw',
  sex: 1
}
// 成员不确定是亦可动态定义，如下
interface Test {
  [key as string]: any;
}
```

### 接口合并

相同的接口会被合并，但必须保证两个接口的相同成员的类型也必须相同

```ts
interface Person {
  readonly name: string;
  sex: number;
  isGirl?: boolean;
}
interface Person {
  sex: number;
  height: number;
}
// 相当于
interface Person {
  readonly name: string;
  sex: number;
  isGirl?: boolean;
  height: number;
}
// 如果第二个的sex为string类型则无法合并，报错，即两个Person相同成员类型需完全相同
```

### 高级类型

ts提供一些高级类型，可以帮助我们快速批量的对接口成员进行转换

1. Partial

```ts
// Partial将成员变为可选
// Partial的源码
type Partial<T> = {
    [P in keyof T]?: T[P];
};
// demo
interface Person {
  sex: number;
  height: number;
}
type person = Partial<Person>
// person相当于
interface person {
  sex?: number;
  height?: number;
}
```

2. Required

```ts
// Required将成员变为必填
// Required的源码
type Required<T> = {
    [P in keyof T]-?: T[P];
};
// demo
interface Person {
  sex?: number;
  height?: number;
}
type person = Required<Person>
// person相当于
interface person {
  sex: number;
  height: number;
}
```

3. Readonly

```ts
// Readonly将成员变为只读
// Readonly源码
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};
// demo
interface Person {
  sex: number;
  height?: number;
}
type person = Required<Person>
// person相当于
interface person {
  readonly sex: number;
  readonly height?: number;
}
```

4. Pick

```ts
// Pick选定已有成员生成新接口，新接口不包含未选定的成员
// Pick源码
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
}
// demo
interface Person {
  sex: number;
  height?: number;
  age: number;
}
type person = Pick<Person, 'height' | 'age'>
// person相当于
interface person {
  height?: number;
  age: number;
}
```


5. Record

```ts
// Record选定成员并指定类型，选中成员变为必填、可写
// Record源码
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
// demo
interface Person {
  readonly sex: number;
  height?: number;
}
type person = Record<'sex' | 'height', string>
// person相当于
interface person {
  sex: number;
  height: number;
}
```

## 函数

函数是非常重要的一部分，一起看看加入ts后如何定义函数以及出入参

```ts
// 写法一
function test(x: number, y: number): number {
  return x + y
}
// 写法二
const test = function(x: number, y: number): number {
  return x + y
}
// 写法三
const test: (x: number, y: number) => number = function(x, y) {
  return x + y
}
// 完整写法
const test: (x: number, y: number) => number = function(x: number, y: number): number {
  return x + y
}
```

### 可选&&默认参数

```js
// 默认参数和es6一样指定一个默认值即可、可选参数通过?:实现，如下
// x必传，y不传时默认为1，z可传可不传，z作为选填参数只能放在最后
const test = (x: number, y: number = 1, z?: number): number => {
  return z ? x + y + z : x + y
}
```

### 重载

```js
// 重载就是同一个函数因不同入参的类型而导致出参也不同
// ts对不同入参出参分别进行定义，达到校验的效果
function test(x: number, y: number): number;
function test(x: number, y: string): string;
function test(x: number, y: any): any{
  if(typeof y == 'number') {
    return x + y;
  } else if (typeof y == 'string') {
    return y;
  }
}
```

## 泛型

聊一下个人的理解：

1. 对类型不确定的定义之初可以不指定类型，通过泛型代替
2. 需要保持类型一致的位置使用泛型
3. 使用时在定义类型，更加灵活
4. 可以将泛型变量(如：T)理解为形参

感觉自己的也不是很好（仅供理解，可跳过该部分），看demo吧

```ts
function test<T>(x: T): T {
  return x
}
// 这是一个最简单的demo，test就可以称之为泛型，T是什么类型在使用时确定
// 例：test(1)则T代表number、test('a')则T代表string
```

常用写法：

```ts
function test<T>(x: T): T {
  return x
}
// 写法一
const t: <T>(x: T) => T = test
// 写法二 字面量对象
const t: { <T>(x: T): T } = test
// 写法三 接口
interface Test {
  <T>(x: T): T
}
const t: Test = test
// 写法四 接口 使用时需定义好类型
interface Test<T> {
  (x: T): T
}
const t: Test<number> = test
```

### 常见泛型变量

1. T(Type): 数据类型
2. K(Key): 对象中的键
3. V(Value): 对象中的值
4. E(Element): 元素类型

## 结语

一时半会写不完，一点点的更新吧
